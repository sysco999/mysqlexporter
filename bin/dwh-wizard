\
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# shellcheck disable=SC1091
source "$ROOT_DIR/lib/ui.sh"

APP_TITLE="DWH Export Wizard"
AUTHOR="Kheireddine BELAID"
GITHUB="https://github.com/sysco999"
DESC="Export selected MySQL tables to CSV (| delimited), optionally map to domains, optionally consolidate 00X chunk files, and optionally upload to a remote server via SFTP."

header() {
  ui_msg "$APP_TITLE" "Author: $AUTHOR\n\nDescription:\n$DESC\n\nGitHub:\n$GITHUB"
}

require_nonempty() {
  local val="$1" label="$2"
  if [[ -z "${val// }" ]]; then
    ui_msg "$APP_TITLE" "‚ùå $label is required. Please try again."
    return 1
  fi
  return 0
}

test_mysql() {
  local mysql_bin="$1" socket="$2" user="$3" pass="$4" db="$5"
  if [[ ! -x "$mysql_bin" ]]; then
    ui_msg "$APP_TITLE" "‚ùå MySQL binary not found or not executable:\n$mysql_bin"
    return 1
  fi
  if [[ ! -S "$socket" ]]; then
    ui_msg "$APP_TITLE" "‚ùå MySQL socket not found:\n$socket"
    return 1
  fi
  "$mysql_bin" -u"$user" -p"$pass" -S "$socket" "$db" -e "SELECT 1;" >/dev/null 2>&1
}

test_sftp_password() {
  local host="$1" user="$2" pass="$3"
  if ! command -v sshpass >/dev/null 2>&1; then
    ui_msg "$APP_TITLE" "‚ùå 'sshpass' is required for password-based SFTP tests.\n\nInstall example (Debian/Ubuntu):\n  sudo apt-get install sshpass\n\nThen re-run the wizard or choose SSH key mode."
    return 1
  fi
  sshpass -p "$pass" sftp -oStrictHostKeyChecking=no -q "$user@$host" </dev/null <<<"bye" >/dev/null 2>&1
}

test_sftp_key() {
  local host="$1" user="$2" key="$3"
  [[ -f "$key" ]] || return 1
  sftp -oIdentityFile="$key" -oBatchMode=yes -oStrictHostKeyChecking=no -q "$user@$host" </dev/null <<<"bye" >/dev/null 2>&1
}

sanitize_var() {
  # turn table name into safe variable suffix: keep [A-Za-z0-9_]
  echo "$1" | tr '-' '_' | sed -E 's/[^A-Za-z0-9_]+/_/g'
}

write_workspace_files() {
  local ws="$1"
  mkdir -p "$ws"
  chmod 700 "$ws"

  # Copy generated scripts from templates
  sed "s|__WS__|$ws|g" "$ROOT_DIR/templates/generate.sh.tpl" > "$ws/generate.sh"
  sed "s|__WS__|$ws|g" "$ROOT_DIR/templates/consolidate.sh.tpl" > "$ws/consolidate.sh"
  sed "s|__WS__|$ws|g" "$ROOT_DIR/templates/uploader.sh.tpl" > "$ws/uploader.sh"
  sed "s|__WS__|$ws|g" "$ROOT_DIR/templates/run_all.sh.tpl" > "$ws/run_all.sh"

  chmod +x "$ws/"*.sh
}

save_config() {
  local ws="$1"
  local cfg="$ws/config.env"
  umask 077
  cat > "$cfg" <<EOF
# Generated by DWH Export Wizard
MYSQL_BIN="$MYSQL_BIN"
MYSQL_SOCKET="$MYSQL_SOCKET"
MYSQL_USER="$MYSQL_USER"
MYSQL_PASS="$MYSQL_PASS"
MYSQL_DB="$MYSQL_DB"

# Output
OUTPUT_DIR="$OUTPUT_DIR"
DEST_TYPE="$DEST_TYPE"   # local|remote
DO_UPLOAD="$DO_UPLOAD"   # yes|no

# SFTP (if remote)
SFTP_MODE="${SFTP_MODE:-}"
SFTP_HOST="${SFTP_HOST:-}"
SFTP_USER="${SFTP_USER:-}"
SFTP_PASS="${SFTP_PASS:-}"
SFTP_KEY_PATH="${SFTP_KEY_PATH:-}"
SFTP_REMOTE_DIR="${SFTP_REMOTE_DIR:-}"

# Consolidation
DO_CONSOLIDATE="$DO_CONSOLIDATE"  # yes|no
RUN_DATE="${RUN_DATE:-$(date +%Y%m%d)}"
EOF
  chmod 600 "$cfg"
}

generate_queries() {
  local ws="$1"
  local qfile="$ws/queries.sh"
  : > "$qfile"
  echo "# Generated by DWH Export Wizard" >> "$qfile"
  echo "# Format: Q_<table>=\"SELECT ...;\"" >> "$qfile"
  echo "" >> "$qfile"

  # Input format: one per line:
  # table_name[:time_column]
  # if time_column omitted, defaults to UPDATE_TIME
  while IFS= read -r line; do
    line="${line//$'\r'/}"
    [[ -z "${line// }" ]] && continue
    # allow comments
    [[ "${line:0:1}" == "#" ]] && continue

    local tbl="${line%%:*}"
    local col=""
    if [[ "$line" == *":"* ]]; then
      col="${line#*:}"
    fi
    [[ -z "$col" ]] && col="UPDATE_TIME"

    local v="Q_$(sanitize_var "$tbl")"

    if [[ -n "${INTERVAL_DAYS:-}" ]]; then
      echo "${v}=\"SELECT * FROM ${tbl} WHERE ${col} >= NOW() - INTERVAL ${INTERVAL_DAYS} DAY;\"" >> "$qfile"
    else
      echo "${v}=\"SELECT * FROM ${tbl};\"" >> "$qfile"
    fi
    echo "" >> "$qfile"
  done <<< "$TABLES_INPUT"

  chmod +x "$qfile"
}

generate_domains() {
  local ws="$1"
  local dfile="$ws/domains.sh"
  : > "$dfile"
  cat > "$dfile" <<'EOF'
#!/usr/bin/env bash
# Generated by DWH Export Wizard
# DOMAIN ‚Üí QUERY MAPPING
declare -A DOMAIN_QUERIES
EOF

  # Parse lines: DOMAIN=table1,table2 or DOMAIN=Q_var1,Q_var2
  while IFS= read -r line; do
    line="${line//$'\r'/}"
    [[ -z "${line// }" ]] && continue
    [[ "${line:0:1}" == "#" ]] && continue

    local dom="${line%%=*}"
    local rest="${line#*=}"
    dom="$(echo "$dom" | tr -d ' ' | tr '[:lower:]' '[:upper:]')"
    if [[ -z "$dom" || "$rest" == "$line" ]]; then
      return 1
    fi

    # Build query names
    local qnames=()
    IFS=',' read -r -a items <<< "$rest"
    for it in "${items[@]}"; do
      it="$(echo "$it" | tr -d ' ')"
      [[ -z "$it" ]] && continue
      if [[ "$it" == Q_* ]]; then
        qnames+=("$it")
      else
        qnames+=("Q_$(sanitize_var "$it")")
      fi
    done

    printf 'DOMAIN_QUERIES[%s]="\n' "$dom" >> "$dfile"
    for q in "${qnames[@]}"; do
      printf '%s\n' "$q" >> "$dfile"
    done
    printf '"\n\n' >> "$dfile"
  done <<< "$DOMAINS_INPUT"

  chmod +x "$dfile"
}

write_consolidate_allowlist() {
  local ws="$1"
  local f="$ws/consolidate_allowlist.txt"
  : > "$f"
  while IFS= read -r line; do
    line="${line//$'\r'/}"
    [[ -z "${line// }" ]] && continue
    echo "$line" >> "$f"
  done <<< "$CONSOLIDATE_TABLES"
  chmod 600 "$f"
}

main() {
  header

  # Choose workspace
  WORKSPACE="$(ui_input "$APP_TITLE" "Choose a workspace folder for this configuration.\n\nAll generated scripts + config.env will be stored there (permissions 700).\n\nExample: /opt/dwh-exporter or /home/user/dwh-exporter" "$HOME/dwh-exporter")" || exit 1
  require_nonempty "$WORKSPACE" "Workspace folder" || main
  mkdir -p "$WORKSPACE"
  chmod 700 "$WORKSPACE"

  # 1) DB config (cannot bypass)
  while true; do
    MYSQL_BIN="$(ui_input "$APP_TITLE" "MySQL client binary path:" "/mysql/mysql8.0/bin/mysql")" || exit 1
    MYSQL_SOCKET="$(ui_input "$APP_TITLE" "MySQL socket path:" "/mysql/data3307/socket/mysqld.sock")" || exit 1
    MYSQL_USER="$(ui_input "$APP_TITLE" "Database user:" "root")" || exit 1
    MYSQL_PASS="$(ui_password "$APP_TITLE" "Database password:")" || exit 1
    MYSQL_DB="$(ui_input "$APP_TITLE" "Database name:" "cre")" || exit 1

    ui_msg "$APP_TITLE" "Testing database connection...\n\nThis step cannot be skipped."
    if test_mysql "$MYSQL_BIN" "$MYSQL_SOCKET" "$MYSQL_USER" "$MYSQL_PASS" "$MYSQL_DB"; then
      ui_msg "$APP_TITLE" "‚úÖ Connection OK. Continuing."
      break
    else
      ui_msg "$APP_TITLE" "‚ùå Connection failed.\n\nPlease verify:\n- MySQL binary path\n- Socket path\n- Username/password\n- Database name\n\nThen try again."
    fi
  done

  # 2) Destination folder (local/remote)
  while true; do
    if ui_yesno "$APP_TITLE" "Do you want to send files to a remote server via SFTP?\n\nYes = remote\nNo  = local"; then
      DEST_TYPE="remote"
      DO_UPLOAD="yes"

      # Choose auth method
      if ui_yesno "$APP_TITLE" "SFTP authentication method:\n\nYes = classic user/password\nNo  = SSH key"; then
        SFTP_MODE="password"
        SFTP_HOST="$(ui_input "$APP_TITLE" "SFTP server IP/Host:" "")" || exit 1
        SFTP_USER="$(ui_input "$APP_TITLE" "SFTP user:" "")" || exit 1
        SFTP_PASS="$(ui_password "$APP_TITLE" "SFTP password:")" || exit 1
        SFTP_REMOTE_DIR="$(ui_input "$APP_TITLE" "Remote destination folder:\n\n(Reminder: check permissions on that folder.)" "/tmp")" || exit 1

        ui_msg "$APP_TITLE" "Testing SFTP connection... (password mode)"
        if test_sftp_password "$SFTP_HOST" "$SFTP_USER" "$SFTP_PASS"; then
          ui_msg "$APP_TITLE" "‚úÖ SFTP connection OK."
          break
        else
          ui_msg "$APP_TITLE" "‚ùå SFTP connection failed.\n\nYou can:\n- Re-enter SFTP info\n- Or go back and select Local output / SSH key mode."
          # loop continues, allowing re-entry
        fi
      else
        SFTP_MODE="key"
        SFTP_HOST="$(ui_input "$APP_TITLE" "SFTP server IP/Host:" "")" || exit 1
        SFTP_USER="$(ui_input "$APP_TITLE" "SFTP user:" "")" || exit 1
        SFTP_KEY_PATH="$(ui_input "$APP_TITLE" "Path to SSH private key (file):" "$HOME/.ssh/id_rsa")" || exit 1
        SFTP_REMOTE_DIR="$(ui_input "$APP_TITLE" "Remote destination folder:\n\n(Reminder: check permissions on that folder.)" "/tmp")" || exit 1

        ui_msg "$APP_TITLE" "Testing SFTP connection... (SSH key mode)"
        if test_sftp_key "$SFTP_HOST" "$SFTP_USER" "$SFTP_KEY_PATH"; then
          ui_msg "$APP_TITLE" "‚úÖ SFTP connection OK."
          break
        else
          ui_msg "$APP_TITLE" "‚ùå SFTP connection failed.\n\nYou can:\n- Re-enter SSH key info\n- Or go back and select Local output"
        fi
      fi
    else
      DEST_TYPE="local"
      DO_UPLOAD="no"
      OUTPUT_DIR="$(ui_input "$APP_TITLE" "Local destination folder for CSV files (full path).\n\nThis is mandatory." "/mysql/data3307/tmp")" || exit 1
      require_nonempty "$OUTPUT_DIR" "Local destination folder" || continue
      mkdir -p "$OUTPUT_DIR"
      break
    fi
  done

  # If remote: still need a local OUTPUT_DIR to generate files first
  if [[ "$DEST_TYPE" == "remote" ]]; then
    OUTPUT_DIR="$(ui_input "$APP_TITLE" "Local staging folder (CSV will be generated here first).\n\nMandatory even for remote upload." "/mysql/data3307/tmp")" || exit 1
    require_nonempty "$OUTPUT_DIR" "Local staging folder" || main
    mkdir -p "$OUTPUT_DIR"
  fi

  # 3) Tables + interval
  INTERVAL_DAYS="$(ui_input "$APP_TITLE" "Interval in days for extraction:\n\nExamples: 1, 2, 3, 30\nLeave empty to extract ALL data (no WHERE clause)." "1")" || exit 1
  # normalize empty to unset
  if [[ -n "${INTERVAL_DAYS// }" ]]; then
    if ! [[ "$INTERVAL_DAYS" =~ ^[0-9]+$ ]]; then
      ui_msg "$APP_TITLE" "‚ö†Ô∏è Interval must be a number (days). Leaving it empty will extract all data."
      INTERVAL_DAYS=""
    fi
  else
    INTERVAL_DAYS=""
  fi

  TABLES_HELP=$'Enter tables to extract (one per line).\n\nFormat:\n  table_name[:time_column]\n\nExamples:\n  account_profile:UPDATE_TIME\n  customer_approval:approval_date\n  bill_000:update_time\n\nIf time_column is omitted, UPDATE_TIME is used.\n'
  TABLES_DEFAULT=$'account_profile:UPDATE_TIME\ncustomer_profile:create_time\n'
  TABLES_INPUT="$(ui_editbox "$APP_TITLE" "$TABLES_HELP" "$TABLES_DEFAULT")" || exit 1
  require_nonempty "$TABLES_INPUT" "Tables list" || main

  # 4) Domains optional
  DO_DOMAINS="no"
  DOMAINS_INPUT=""
  if ui_yesno "$APP_TITLE" "Do you want to configure DOMAINS mapping (like domains.sh)?\n\nThis is optional.\nYes = configure\nNo  = bypass"; then
    DO_DOMAINS="yes"

    DOMAINS_HELP=$'Provide domain mapping lines in this format:\n\nDOMAIN=table1,table2,table3\n\nExample:\nBILL=bill_000,bill_001,bill_transaction_000\nCUSTOMER=customer_profile,customer_approval\n\nTip: domains are uppercase, tables can be raw table names.\n\nCancel to bypass this step.'
    DOMAINS_DEFAULT=$'BILL=bill_000,bill_001\nCUSTOMER=customer_profile,customer_approval\n'
    while true; do
      DOMAINS_INPUT="$(ui_editbox "$APP_TITLE" "$DOMAINS_HELP" "$DOMAINS_DEFAULT")" || { DO_DOMAINS="no"; break; }
      # quick validate
      if [[ -z "${DOMAINS_INPUT// }" ]]; then
        DO_DOMAINS="no"
        break
      fi
      # try parse into file (in memory check by running function on temp ws)
      tmpws="$(mktemp -d)"
      TABLES_INPUT="$TABLES_INPUT" INTERVAL_DAYS="$INTERVAL_DAYS"
      generate_queries "$tmpws"
      if DOMAINS_INPUT="$DOMAINS_INPUT" generate_domains "$tmpws"; then
        rm -rf "$tmpws"
        break
      else
        rm -rf "$tmpws"
        if ui_yesno "$APP_TITLE" "‚ùå Domains input looks invalid.\n\nYes = Try again\nNo  = Bypass domains"; then
          continue
        else
          DO_DOMAINS="no"
          DOMAINS_INPUT=""
          break
        fi
      fi
    done
  fi

  # 5) Consolidation optional
  DO_CONSOLIDATE="no"
  CONSOLIDATE_TABLES=""
  if ui_yesno "$APP_TITLE" "Do you want to consolidate 00X chunk files into one file per family?\n\nYes = choose tables to consolidate\nNo  = skip consolidation"; then
    DO_CONSOLIDATE="yes"
    CONSOLIDATE_HELP=$'Enter base table names to consolidate (one per line).\n\nExamples:\n  bill\n  bill_transaction\n  bill_item\n  account_credit_limit_log\n\nThese are matched against filenames like:\n  DOMAIN#bill_transaction_000_YYYYMMDDHHMMSS.csv\n\nLeave empty to consolidate ALL detected families.'
    CONSOLIDATE_TABLES="$(ui_editbox "$APP_TITLE" "$CONSOLIDATE_HELP" $'bill\nbill_transaction\n') " || true
  fi

  # 6) Generate workspace files
  write_workspace_files "$WORKSPACE"
  generate_queries "$WORKSPACE"
  if [[ "$DO_DOMAINS" == "yes" && -n "${DOMAINS_INPUT// }" ]]; then
    generate_domains "$WORKSPACE"
  else
    rm -f "$WORKSPACE/domains.sh" || true
  fi

  if [[ "$DO_CONSOLIDATE" == "yes" && -n "${CONSOLIDATE_TABLES// }" ]]; then
    write_consolidate_allowlist "$WORKSPACE"
  else
    rm -f "$WORKSPACE/consolidate_allowlist.txt" || true
  fi

  save_config "$WORKSPACE"

  ui_msg "$APP_TITLE" "‚úÖ Configuration saved in:\n$WORKSPACE\n\nNext:\n- Run export:  $WORKSPACE/run_all.sh\n\nFiles will be in:\n$OUTPUT_DIR"

  # Offer to run now
  if ui_yesno "$APP_TITLE" "Run export now?"; then
    bash "$WORKSPACE/run_all.sh"
    ui_msg "$APP_TITLE" "üéâ Done.\n\nCheck files in:\n$OUTPUT_DIR\n\nWorkspace:\n$WORKSPACE"
  fi
}

main
